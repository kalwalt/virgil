// Copyright 2022 Virgil authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def SPACE = AddressSpace.new("mem", false, 64, 8,
	Alignment.new(4096), Alignment.new(8));

def LOWERING = MachLoweringConfig.new();
def X86_64_DARWIN_TARGET = Aeneas.registerTarget(
		DarwinTarget.new("x86-64-darwin", SPACE, IntNormalizers.I64LE, X86_64Common.LOWERING,
			X86_64DarwinBackend.new(_, _, _, _, _, false),
			MachO_X86ThreadState.new, MachO.CPU_TYPE_X86_64));
def X86_64_DARWIN_TEST_TARGET = Aeneas.registerTarget(
		DarwinTarget.new("x86-64-darwin-test", SPACE, IntNormalizers.I64LE, X86_64Common.LOWERING,
			X86_64DarwinBackend.new(_, _, _, _, _, true),
			MachO_X86_64ThreadState.new, MachO.CPU_TYPE_X86_64));

// Constants for system calls.
def SYS_exit = 0x2000001;
def SYS_write = 0x2000004;
def SYS_sigaction = 0x200002E;
def SYS_RT_sigreturn = 0x20000B8;

def Regs: X86_64Regs;
def MRegs: X86_64RegSet;

// Darwin-specific backend code generation.
class X86_64DarwinBackend extends X86_64Backend {
	def SYSNUM = Regs.RAX;
        def PARAM0 = Regs.RDI;
        def PARAM1 = Regs.RSI;
        def PARAM2 = Regs.RDX;
        def PARAM3 = Regs.R10;
        def PARAM4 = Regs.R8;
        def PARAM5 = Regs.R9;

	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf,
		test: bool) super(compiler, prog, mach, w, null, test) {
	}
	def asm_exit_code(code: int) {
		asm.movd_r_i(SYSNUM, SYS_exit);
		asm.movd_r_i(PARAM0, code);
		asm.syscall();
	}
	def asm_exit_r(r: X86_64Gpr) {
		asm.movq_r_r(PARAM0, r);
		asm.movd_r_i(SYSNUM, SYS_exit);
		asm.syscall();
	}
	def genTestOutput(main: IrMethod, frame: MachFrame) {
		// output the return register as a 4-byte integer to stdout
		var rt = main.sig.returnType();
		var gpr = loc_gpr(frame, frame.conv.callerRet(0));
		match (rt) { // sign- or zero-extend subword return values
			x: IntType => if (x.width < 32) {
				if (x.signed) {
					if (x.width <= 8) asm.movbsx_r_r(gpr, gpr);
					else if (x.width <= 16) asm.movwsx_r_r(gpr, gpr);
				} else {
					if (x.width <= 8) asm.movbzx_r_r(gpr, gpr);
					else if (x.width <= 16) asm.movwzx_r_r(gpr, gpr);
				}
			}
			_ => match (mach.sizeOf(rt)) {
				0 => asm.movd_r_i(gpr, 0);
				1 => asm.movbzx_r_r(gpr, gpr);
				2 => asm.movwzx_r_r(gpr, gpr);
			}
		}
		asm.pushq_r(gpr);
		asm.movd_r_i(SYSNUM, SYS_write);
		asm.movd_r_i(PARAM0, 1); // stdout
		asm.movq_r_r(PARAM1, Regs.RSP);	// integer is on stack
		asm.movd_r_i(PARAM2, 4);	// size to write
		asm.syscall();
	}
	def genSignalHandlerStub() {
		var handler_meth = mach.runtime.getRiSignal();
		if (handler_meth == null) return;
		var frame = getFrame(handler_meth.ssa);
		mach.runtime.recordAddr(CiRuntimeModule.SIGNAL_STUB, w.endAddr());

		// save RBP; V3 execution uses it as scratch
		asm.pushq_r(Regs.RBP);
		// from kernel:
		asm.pushq_r(Regs.R8); // ucontext
		asm.pushq_r(Regs.RSI); // siginfo
		asm.pushq_r(Regs.RDX); // signal number
		// "this" = null
		asm.movd_r_i(MRegs.toGpr(frame.conv.calleeParam(0)), 0); // "this" = null
		// param 1 = signum
		asm.popq_r(MRegs.toGpr(frame.conv.calleeParam(1)));
		// param 2 = siginfo
		asm.popq_r(MRegs.toGpr(frame.conv.calleeParam(2)));
		// param 3 = ucontext
		asm.popq_r(MRegs.toGpr(frame.conv.calleeParam(3)));

		// call RiRuntime.signal(signum: int, siginfo: Pointer, ucontext: Pointer)
		asm.callr_v3(mach.addrOfMethod(handler_meth));
		// RiRuntime.signal may return
		asm.popq_r(Regs.RBP);
		asm.ret();
		// restorer stub for X86-64
		mach.runtime.recordAddr(CiRuntimeModule.SIGNAL_RESTORER, w.endAddr());
		asm.movd_r_i(SYSNUM, SYS_RT_sigreturn);
		asm.syscall();
	}
	def genFatalStub(ex: string, addr: Addr) {
		addr.absolute = w.endAddr();
		// 1. encode a call to write() on stderr
		var msgAddr = Addr.new(mach.codeRegion, null, 0);
		asm.movd_r_i(SYSNUM, SYS_write);
		asm.movd_r_i(PARAM0, 2); // stderr
		asm.lea(PARAM1, X86_64AddrRef.new(null, null, 1, msgAddr, false));	// buffer
		asm.movq_r_i(PARAM2, ex.length + 1);		// write size
		asm.syscall();
		// 2. encode a call to exit()
		asm_exit_code(-1);
		// 3. output message at end of code
		msgAddr.absolute = w.endAddr();
		w.putb('!');
		w.puta(ex);
		w.atEnd();
	}
	def genSigHandlerInstall(signo: int, handler: Addr) {
		// XXX: reduce duplication with RiOS.installHandler
		// construct sigaction (in reverse order) on the stack
		asm.pushq_i(0x04000000); // sa_flags
		asm.pushq_i(0); // sa_mask
		asm.lea(Regs.RBP, X86_64AddrRef.new(null, null, 1, handler, false)); // XXX: pushq_i with patch
		asm.pushq_r(Regs.RBP); // sa_handler
		//asm.pushq_i(0x08000000); // sa_restorer (fatal signal handlers never return)
		//TODO: why is handler address put in the wrong place?
		asm.pushq_r(Regs.RBP); // sa_handler
		def struct_size = 4 * 8;

		asm.movd_r_i(SYSNUM, SYS_sigaction);
		asm.movd_r_i(PARAM0, signo);	// signo
		asm.movq_r_r(PARAM1, Regs.RSP);	// sigaction*
		asm.movd_r_i(PARAM2, 0);	// old sigaction*
		asm.movd_r_i(PARAM3, 8);	// sigsetsize
		asm.syscall();
		asm.add_r_i(Regs.RSP, struct_size);
	}
}

// a mach-O thread state command for x86-64
class MachO_X86_64ThreadState extends MachO_ThreadState {
	def encode(is64: bool, w: DataWriter) {
		w.put_b32(0x5); 				// unix thread
		w.put_b32(21 * 8 + 4 * 4);  			// 184 bytes for x86-64
		w.put_b32(MachO.X86_64_THREAD_STATE_FLAVOR);    // x86-64 thread state flavor
		w.put_b32(42); 				        // number of words
		w.zeroN(21 * 8);
		var current_pos = w.pos;
		w.at(w.pos - 5 * 8);
		w.put_b64(rip);
		w.at(current_pos);
	}
	def size(is64: bool) -> int {
		return 21 * 8 + 4 * 4;
	}
}
