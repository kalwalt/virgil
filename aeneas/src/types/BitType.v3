// Copyright 2024 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Bits {
	def MAX_WIDTH = 255;
	private def cache = Array<BitType>.new(MAX_WIDTH + 1);

	def getType(width: int) -> BitType {
		if (width <= 0 || width > MAX_WIDTH) return null;
		var index = width;
		var t = cache[index];
		if (t == null) t = cache[index] = BitType.!(Bit_TypeCon.new(byte.view(width)).singleton);
		return t;
	}
	def getTypeCon(width: int) -> Bit_TypeCon {
		var t = getType(width);
		return if(t != null, Bit_TypeCon.!(t.typeCon));
	}
	def lookupType(name: string) -> Bit_TypeCon {
		if (name.length > 4) return null;
		var width = name[1] - int.view('0');
		if (width < 1 || width > 9) return null;
		for (i = 2; i < name.length; i++) {
			var digit = name[i] - int.view('0');
			if (digit < 0 || digit > 9) return null;
			width = width * 10 + digit;
		}
		return getTypeCon(width);
	}
}

class Bit_TypeCon extends TypeCon {
	new(width: byte) super(bitTypeName(width), Kind.INT, 0, TypeUtil.globalCache) {
		singleton = BitType.new(width, this);
	}
}

class BitType extends Type {
	def width: byte;
	var cache: BitOpCache;

	new(width, typeCon: Bit_TypeCon) super(typeCon.uid, typeCon, null) { }

	def byteSize() -> int {
		if (width <= 8) return 1;
		if (width <= 16) return 2;
		if (width <= 32) return 4;
		if (width <= 64) return 8;
		if (width <= 128) return 16;
		return 32;
	}
	def opAnd() -> Operator { return opcache().andOp; }
	def opOr() -> Operator { return opcache().orOp; }
	def opXor() -> Operator { return opcache().xorOp; }
	def opShl() -> Operator { return opcache().shlOp; }
	def opShr() -> Operator { return opcache().shrOp; }
	def opcache() -> BitOpCache {
		if (cache == null) cache = BitOpCache.new(this);
		return cache;
	}
}

class BitOpCache(bitType: BitType) {
	private def t: Array<Type> = [bitType];
	private def tt: Array<Type> = [bitType, bitType];
	private var sig = Function.siga(tt, bitType);

	def andOp = Operator.new(Opcode.IntAnd, t, sig);
	def orOp = Operator.new(Opcode.IntOr, t, sig);
	def xorOp = Operator.new(Opcode.IntXor, t, sig);
	def shlOp = Operator.new(Opcode.IntShl, t, sig);
	def shrOp = Operator.new(Opcode.IntShr, t, sig);
//TODO negOp
}

def bitTypeName(width: byte) -> string {
	var buf = Array<byte>.new(1 + width);
	buf[0] = 'b';
	Ints.renderPosDecimal(width, buf, 1);
	return buf;
}
