// Copyright 2011 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def SPACE = AddressSpace.new("mem", false, 32, 4,
	Alignment.new(4096), Alignment.new(4));

def LOWERING = MachLoweringConfig.new();
def X86_DARWIN_TARGET = Aeneas.registerTarget(
		DarwinTarget.new("x86-darwin", SPACE, IntNormalizers.I32LE, LOWERING,
			X86DarwinBackend.new(_, _, _, _, _, false),
			MachO_X86ThreadState.new, MachO.CPU_TYPE_X86));
def X86_DARWIN_TEST_TARGET = Aeneas.registerTarget(
		DarwinTarget.new("x86-darwin-test", SPACE, IntNormalizers.I32LE, LOWERING,
			X86DarwinBackend.new(_, _, _, _, _, true),
			MachO_X86ThreadState.new, MachO.CPU_TYPE_X86));

// Darwin-specific backend code generation.
class X86DarwinBackend extends X86Backend {
	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf, test: bool) super(compiler, prog, mach, w, test) {
	}
	def asm_exit_code(code: int) {
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.push_i(code);
		asm.push_i(0);
		asm.intK(0x80);
	}
	def asm_exit_rm(rm: X86Rm) {
		asm.push(rm);
		asm.movd_rm_i(X86Regs.EAX, 1); // sys_exit() = 1
		asm.push_i(0);
		asm.intK(0x80);
	}
	def genTestOutput(frame: MachFrame) {
		// output the return register as a 4-byte integer to stdout
		asm.push(asm.loc_rm(frame, frame.conv.callerRet(0)));
		asm.movd_rm_r(X86Regs.EBX, X86Regs.ESP);
		asm.push_i(4);			// size to write
		asm.push(X86Regs.EBX);		// pointer into stack
		asm.push_i(1);			// stdout
		asm.push_i(0);
		asm.movd_rm_i(X86Regs.EAX, 4); // write()
		asm.intK(0x80);
	}
	def genSignalHandlerStub() {
		// Specialized assembly to directly handle a signal from the kernel
		var frame = getFrame(ri_signal.ssa);
		mach.runtime.recordAddr(CiRuntimeModule.SIGNAL_STUB, asm.machBuffer.posAddr());
		// "this" = null
		asm.movd_rm_i(asm.loc_rm(frame, frame.conv.calleeParam(0)), 0); // "this" = null
		var scratch = X86RegSet.SCRATCH;
		// param 1 = signum @ [esp + 12]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(1)), X86Regs.ESP.plus(3 * mach.data.addressSize), scratch);
		// param 2 = siginfo @ [esp + 16]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(2)), X86Regs.ESP.plus(4 * mach.data.addressSize), scratch);
		// param 3 = ucontext @ [esp + 20]
		asm.movd_rm_rm(asm.loc_rm(frame, frame.conv.calleeParam(3)), X86Regs.ESP.plus(5 * mach.data.addressSize), scratch);
		// call RiRuntime.signal(signum: int, siginfo: Pointer, ucontext: Pointer)
		asm.call_addr(mach.addrOfMethod(ri_signal));
		// should not return
	}
	def genFatalStub(ex: string, addr: Addr) {
		var asm = X86Assembler.new(w);
		addr.absolute = w.endAddr();
		// 1. encode a call to write() on stderr
		asm.push_i(ex.length + 1);			// size to write
		asm.push_i(X86Addrs.ABS_CONST);			// pointer to msg
		var msgAddrPos = asm.pos() - 4;
		asm.push_i(2);					// stderr
		asm.push_i(0);					// unused
		asm.movd_rm_i(X86Regs.EAX, 4);			// write()
		asm.intK(0x80);
		// 2. encode a call to exit()
		asm.push_i(-1);
		asm.push_i(-1);
		asm.movd_rm_i(X86Regs.EAX, 1);			// exit()
		asm.intK(0x80);
		// 3. output message at end of code
		var msgAddr = w.posAddr();
		w.putb('!');
		w.puta(ex);
		w.at(msgAddrPos).put_b32(msgAddr);
		w.atEnd();
	}
	// generate code that installs a signal handler
	def genSigHandlerInstall(signo: int, handler: Addr) {
		asm.push_i(0);			// sa_flags
		asm.push_i(0);			// sa_mask
		asm.push_i(X86Addrs.ABS_CONST);	// sa_handler: handler address
		recordPatch(handler);
		asm.push_i(2);			// TODO: why a nonzero value here?
		asm.movd_rm_r(X86Regs.EBX, X86Regs.ESP);
		asm.push_i(0);			// sigaction *oact
		asm.push(X86Regs.EBX);		// sigaction *act
		asm.push_i(signo);		// signal number
		asm.push_i(0);			// "dummy" value
		asm.movd_rm_i(X86Regs.EAX, 46); // sigaction
		asm.intK(0x80);
		asm.add.rm_i(X86Regs.ESP, 32);	// pop params off stack
	}
}
// a mach-O thread state command for x86
class MachO_X86ThreadState extends MachO_ThreadState {
	def encode(is64: bool, w: DataWriter) {
		w.put_b32(0x5); // unix thread
		w.put_b32(80);  // 80 bytes for x86
		w.put_b32(1);   // X86 thread state
		w.put_b32(16);  // number of words
		// eax ebx ecx edx edi
		w.zeroN(5 * 4);
		// esi ebp esp ss eflags
		w.zeroN(5 * 4);
		// entrypoint address
		w.put_b32(rip);
		// cs ds es fs gs
		w.zeroN(5 * 4);
	}
	def size(is64: bool) -> int {
		return 80;
	}
}
